import { BaseMessage } from '@langchain/core/messages'

import { StrategyResult } from 'src/media-operations/request-handling/types/strategy-result.type'

/**
 * Shared assertion helpers for testing media operation strategies
 */

// ============================================================================
// Types
// ============================================================================

export type ContextType = 'movie' | 'movieDelete' | 'tvShow' | 'tvShowDelete'

export interface StrategyResultExpectation {
  /** Expected number of messages */
  messageCount?: number
  /** Expected message content (partial match) */
  messageContent?: string
  /** Specific message to match */
  specificMessage?: BaseMessage
  /** Expected images array */
  images?: Array<{ title: string; url: string; parentId?: string }>
  /** Whether images should exist (any) */
  hasImages?: boolean
}

// ============================================================================
// Assertion Helpers
// ============================================================================

/**
 * Assert that a strategy result matches expected values
 *
 * @example
 * assertStrategyResult(result, {
 *   messageCount: 1,
 *   images: []
 * })
 *
 * @example
 * assertStrategyResult(result, {
 *   messageCount: 1,
 *   specificMessage: mockChatResponse
 * })
 */
export function assertStrategyResult(
  result: StrategyResult,
  expected: StrategyResultExpectation,
): void {
  // Assert messages
  expect(result.messages).toBeDefined()

  if (expected.messageCount !== undefined) {
    expect(result.messages).toHaveLength(expected.messageCount)
  }

  if (expected.specificMessage !== undefined) {
    expect(result.messages[0]).toBe(expected.specificMessage)
  }

  if (expected.messageContent !== undefined) {
    const firstMessage = result.messages[0]
    expect(firstMessage?.content).toContain(expected.messageContent)
  }

  // Assert images
  if (expected.images !== undefined) {
    expect(result.images).toEqual(expected.images)
  }

  if (expected.hasImages === true) {
    expect(result.images.length).toBeGreaterThan(0)
  } else if (expected.hasImages === false) {
    expect(result.images).toEqual([])
  }
}

/**
 * Assert that a context was set on the state service
 *
 * @example
 * assertContextSet(mockState, 'user123', 'movie', {
 *   searchResults: [mockMovie1, mockMovie2],
 *   query: 'matrix'
 * })
 */
export function assertContextSet(
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  mockState: any,
  userId: string,
  contextType: ContextType,
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  expectedData?: any,
): void {
  const methodMap = {
    movie: 'setUserMovieContext',
    movieDelete: 'setUserMovieDeleteContext',
    tvShow: 'setUserTvShowContext',
    tvShowDelete: 'setUserTvShowDeleteContext',
  }

  const method = methodMap[contextType]
  expect(mockState[method]).toHaveBeenCalled()

  if (expectedData !== undefined) {
    expect(mockState[method]).toHaveBeenCalledWith(userId, expectedData)
  }
}

/**
 * Assert that a context was NOT set on the state service
 *
 * @example
 * assertContextNotSet(mockState, 'movie')
 */
export function assertContextNotSet(
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  mockState: any,
  contextType: ContextType,
): void {
  const methodMap = {
    movie: 'setUserMovieContext',
    movieDelete: 'setUserMovieDeleteContext',
    tvShow: 'setUserTvShowContext',
    tvShowDelete: 'setUserTvShowDeleteContext',
  }

  const method = methodMap[contextType]
  expect(mockState[method]).not.toHaveBeenCalled()
}

/**
 * Assert that a prompt was generated by the prompt service
 *
 * @example
 * assertPromptGenerated(mockPromptService, 'generateMoviePrompt')
 *
 * @example
 * assertPromptGenerated(mockPromptService, 'generateMoviePrompt', {
 *   callIndex: 0,
 *   expectedArgs: ['search', expect.any(Object)]
 * })
 */
export function assertPromptGenerated(
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  mockPromptService: any,
  methodName: string,
  options?: {
    /** Which call to check (default: 0) */
    callIndex?: number
    /** Expected arguments for the call */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    expectedArgs?: any[]
    /** Expected number of times called */
    callCount?: number
  },
): void {
  const method = mockPromptService[methodName]
  expect(method).toHaveBeenCalled()

  if (options?.callCount !== undefined) {
    expect(method).toHaveBeenCalledTimes(options.callCount)
  }

  if (options?.expectedArgs !== undefined) {
    const callIndex = options.callIndex ?? 0
    expect(method).toHaveBeenNthCalledWith(
      callIndex + 1,
      ...options.expectedArgs,
    )
  }
}
